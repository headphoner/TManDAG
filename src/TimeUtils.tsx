import { UUID, Task } from "./Tasks";

/**
 * Represents a span between two points of time
 */
export type Timespan = {
    /** Start of the time span, given in milliseconds since Unix epoch (1 Jan 1970, UTC) */
    readonly timeFrom: number,
    /** End of the time span, given in milliseconds since Unix epoch (1 Jan 1970, UTC) */
    readonly timeUntil: number
};

/**
 * Represnts a instance of a task being scheduled
 * @param uuid - The UUID of the {@link Task} which is scheduled for this instance
 * @param during - The time during which the task with UUID `uuid` is scheduled
 */
export type ScheduledInstance = {
    uuid: UUID,
    during: Timespan
};

/**
 * Represents a recipe for scheduling a {@link Task} during a single timespan
 */
export type ScheduleOnceRecipe = {
    type: 'single',
    /** The timespan during which the task is scheduled */
    timespan: Timespan
};

/**
 * Represents a recipe for scheduling a {@link Task} on a recurring basis
 * @todo
 */
export type ScheduleRecurringDaysRecipe = { type: 'recurring' };

/**
 * Represents a recipe for scheduling a {@link Task}
 */
export type ScheduleRecipe = ScheduleOnceRecipe | ScheduleRecurringDaysRecipe;

/**
 * Get whether two timespans overlap
 * @param a - The first timespan
 * @param b - The second timespan
 * @returns Whether the overlap of `a` and `b` has positive measure
 */
export function getDoTimespansOverlap(a: Timespan, b: Timespan) {
    return Math.max(a.timeFrom, b.timeFrom) < Math.min(a.timeUntil, b.timeUntil);
}

/**
 * Get the times for which a schedule recipe is scheduled during some period
 * @param recipe - The input schedule recipe which generates the scheduled instances
 * @param during - The duration in which we get the scheduled instances of `recipe`
 * @returns All of the instances for which `recipe` is scheduled in `during`
 */
export function getScheduleDuring(recipe: ScheduleRecipe, during: Timespan): Timespan[] {
    let out: Timespan[] = [ ];
    switch (recipe.type) {
        case 'single':
            if (getDoTimespansOverlap(recipe.timespan, during)) out.push(recipe.timespan);
            break;
        case 'recurring':
            // TODO
            break;
    }
    return out.sort((t1, t2) => t1.timeFrom - t2.timeFrom);
}

/**
 * Find the earliest scheduled instance for a recipe (optional: after a certain time)
 * @param recipe - the recipe which generates the scheduled instances
 * @param [startingFrom] - the time after which we require in milliseconds since Unix epoch (1 Jan 1970, UTC)
 * @returns The earliest scheduled instance generated by `recipe` (after `startingFrom`)
 */
export function getSoonestScheduledTimespan(recipe: ScheduleRecipe, startingFrom: number = Number.MIN_SAFE_INTEGER) {
    switch (recipe.type) {
        case 'single':
            if (recipe.timespan.timeUntil >= startingFrom)
                return recipe.timespan;
            else
                break;
        case 'recurring':
            /** @todo */
            break;
    }
    return null;
}